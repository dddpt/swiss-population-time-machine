/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/Commune.js":
/*!***********************!*\
  !*** ./js/Commune.js ***!
  \***********************/
/*! exports provided: Commune */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Commune\", function() { return Commune; });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./js/util.js\");\n\n\nclass Commune{\n  constructor(\n    bfsnr,\n    name,\n    canton,\n    firstmention,\n    hab_year,\n    latitude, //Y\n    longitude, //X\n    url,\n    zipcodes,\n    language,\n    notes,\n    populationExtrapolator\n  ){\n    this.name = name\n    this.bfsnr = +bfsnr\n    this.canton = canton\n    this.firstmention = firstmention\n    this.hab_year = hab_year\n    this.hab_year = this.hab_year.sort((a,b)=>a.year-b.year)\n    this.latitude = +latitude\n    this.longitude = +longitude \n    this.latLng = [this.latitude, this.longitude]\n    this.url = url\n    this.zipcodes = zipcodes\n    this.language = language\n    this.notes = notes\n    this.extrapolatePopulation = year => populationExtrapolator(this, year)\n    this.interpolatePopulation = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[\"exponentialInterpolator\"])(this.hab_year.map(hy=>[hy.year,hy.pop]))\n  }\n\n  calculatePopulation(year){\n    if(this.hasPopulationData(year)){\n      return this.interpolatePopulation(year)\n    } else {\n      return this.extrapolatePopulation(year)\n    }\n  }\n\n  hasPopulationData(year){\n    if(this.hab_year.length<1){\n      console.log()\n      return false\n    }\n    let firsthy = this.hab_year[0]\n    let lasthy = this.hab_year[this.hab_year.length-1] \n    return firsthy.year<=year && lasthy.year>=year\n  }\n  \n}\n\n//# sourceURL=webpack:///./js/Commune.js?");

/***/ }),

/***/ "./js/HistoricalPopulationGraph.js":
/*!*****************************************!*\
  !*** ./js/HistoricalPopulationGraph.js ***!
  \*****************************************/
/*! exports provided: HistoricalPopulationGraph */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HistoricalPopulationGraph\", function() { return HistoricalPopulationGraph; });\n\n\n// SPTM - Didier Dupertuis & Nicolas Vallotton - Avril 2019\n\nclass HistoricalPopulationGraph{\n\n  /** HistoricalPopulationGraph constructor\n   * \n   * @param {String} divId the id of the div in which the graph should be put\n   * @param {Array[Commune]} communes array of Commune Objects\n   * @param {number} minYear the minimum year that can be displayed\n   * @param {number} maxYear the maximum year that can be displayed\n   */\n  constructor(\n      divId,\n      legendDivId,\n      minYear,\n      maxYear, \n      colors,\n      maxSize = 3,\n      transitionsDuration = 1000,\n      dimensions = [440, 320],\n      margins = {top : 20, right : 40, bottom : 30, left : 52}\n    ){\n    let self = this\n    this.divId = divId\n    this.legendDivId = legendDivId\n    this.minYear = minYear\n    this.maxYear = maxYear\n    this.tooltip = undefined\n    this.width = dimensions[0] - margins.left - margins.right;\n    this.height = dimensions[1] - margins.top - margins.bottom;\n    this.margins = margins\n    \n    \n    this.displayedCommunes =[]\n    // Boolean to check if graph has already been initialized\n    this.initialized = false\n    // Max nb of communes to display on graph\n    this.maxSize = 3\n    this.counter =0\n    let ms2 = 1/(maxSize+2)\n    this.colors = colors? colors : d3.range(ms2, 1, ms2).map(d3.interpolateRainbow)\n    this.colorScale = function(){\n      let usedColors = self.displayedCommunes.map(c=>c.graphColor)\n      let freeColors = self.colors.filter(color => !usedColors.includes(color))\n      if(freeColors.length>0){\n        return freeColors[0]\n      }\n      return \"black\"\n    }\n    this.transitionsDuration = transitionsDuration\n  }\n\n  init(){\n    let self = this\n    // Removing introduction text for graph\n    $('#tuto').remove();\n\n    // Creating svg, appending attributes\n    this.svg = d3.select(\"#\"+this.divId)\n      .append(\"svg\")\n      .attr(\"width\", self.width + self.margins.left + self.margins.right)\n      .attr(\"height\", self.height + self.margins.top + self.margins.bottom)\n      .append(\"g\")\n      .attr(\"transform\", `translate(${self.margins.left},${self.margins.top})`);\n\n    // Adding div tooltip\n    this.tooltip = d3.select(\"#\"+this.divId)\n      .append('div')\n      .attr('class', 'tooltipGraph')\n      .style('left', '0px')\n      .style('top', '0px')\n      .style('opacity',0);\n\n    // Adding grid\n    // X gridlines\n    this.svg.append(\"g\")\t\t\t\n      .attr(\"class\", \"xgrid\")\n      .attr(\"transform\", `translate(0,${self.height})`);\n\n    // Y gridlines\n    this.svg.append(\"g\")\t\t\t\n      .attr(\"class\", \"ygrid\")\n\n    // Adding axis\n    this.svg.append('g')\n      .attr('class','xAxis')\n      .attr('transform', `translate(0,${self.height})`);\n\n    this.svg.append('g')\n      .attr('class', 'yAxis');\n\n    // Adding axis labels\n    this.svg.append(\"text\")\n      .attr('class', 'axisLabel')\n      .attr(\"text-anchor\", \"middle\")  // this makes it easy to centre the text as the transform is applied to the anchor\n      .attr(\"transform\", \"translate(\"+ (20) +\",\"+(35)+\")rotate(-90)\")  // text is drawn off the screen top left, move down and out and rotate\n      .style('opacity', 0)\n      .text(\"Population\");\n\n    this.svg.append(\"text\")\n      .attr('class', 'axisLabel')\n      .attr(\"text-anchor\", \"middle\")  // this makes it easy to centre the text as the transform is applied to the anchor\n      .attr(\"transform\", \"translate(\"+ (self.width-(20)) +\",\"+(self.height-(10))+\")\")  // centre below axis\n      .style('opacity', 0)\n      .text(\"AnnÃ©e\");\n\n  }\n\n  addCommune(newCommune){\n    //cl(\"this.displayedCommunes: \", this.displayedCommunes)\n    if(!this.displayedCommunes.find(c => c.name==newCommune.name)){\n      newCommune.graphColor = this.colorScale()\n      this.counter = this.counter+1\n  \n      // insert newCommune at beginning of array \n      this.displayedCommunes.unshift(newCommune)\n  \n      this.update()\n    }\n  }\n\n  removeCommune(communeToRemove){\n    let ctrIndex = this.displayedCommunes.findIndex(c => c.name==communeToRemove.name)\n    if(ctrIndex!=-1){\n      this.displayedCommunes.splice(ctrIndex,1)\n      this.update()\n    }\n  }\n\n  update() {\n    let self = this\n    if(!this.initialized){\n      this.init()\n      this.initialized = true\n    }\n\n    // Setting up X scale and axis\n    let xScale = d3.scaleLinear().range([0,self.width]).domain([1200,2000]);\n    let xAxis = d3.axisBottom().scale(xScale);\n\n    // only keep the first this.maxSize elements \n    this.displayedCommunes = this.displayedCommunes.filter((c,i)=> i<this.maxSize)\n\n    // Setting up Y scale and axis\n    let yMax = d3.max(self.displayedCommunes.filter((c,i)=> i<self.maxSize).map(commune => commune.hab_year.map(hy =>hy.pop)).flat())\n    let yScale = d3.scaleLinear().range([self.height,0]).domain([0,1.1*yMax]);\n    let yAxis = d3.axisLeft().scale(yScale);\n\n    // Rescale axis\n    this.svg.select('.xAxis')\n      .transition()\n      .duration(self.transitionsDuration)\n      .call(xAxis)\n      .attr('x', self.width)\n      .attr('y', -3);\n\n    this.svg.select('.yAxis')\n      .transition()\n      .duration(self.transitionsDuration)\n      .call(yAxis)\n      .attr('y',6)\n      .attr('dy', '.71em');\n\n    this.svg.selectAll('.axisLabel')\n      .style('opacity', 1);\n\n    // Rescale grid\n    this.svg.select('.xgrid')\n      .transition()\n      .duration(self.transitionsDuration)\n      .call(xAxis\n        .tickSize(-self.height)\n        .tickFormat(\"\")\n      )\n      .attr('x', self.width)\n\n    this.svg.select('.ygrid')\n      .transition()\n      .duration(self.transitionsDuration)\n      .call(yAxis\n        .tickSize(-self.width)\n        .tickFormat(\"\")\n      )\n\n\n    // create the legend\n    let legendDiv = d3.select(\"#\"+self.legendDivId).selectAll(\".graph-commune-legend\").data(\n      self.displayedCommunes.filter((c,i)=>i<self.maxSize),\n      function(c){return c? \"legend-\"+c.name : this.id} // /!\\ function(){} needed here! arrow func not allowed\n    )\n\n    let legendDivEnter = legendDiv.enter()\n      .append(\"div\")\n      .attr(\"id\", self.legendId)\n      .attr(\"class\",\"graph-commune-legend\")\n    legendDivEnter.append(\"span\")\n      .html(\"x \")\n      .attr(\"class\",\"remove-commune-from-graph\")\n      .on(\"click\", c => self.removeCommune(c))\n    legendDivEnter.append(\"span\")\n      .html(c => c.name)\n      .style('color', c => c.graphColor);\n    legendDivEnter.append(\"span\")\n      .html(\" (\")\n    legendDivEnter.append(\"a\")\n      .attr(\"href\", c=> \"https://beta.hls-dhs-dss.ch\"+c.url.replace(\"de\",\"fr\"))\n      .attr(\"target\",\"_blank\")\n      .html(\"dhs\")\n    legendDivEnter.append(\"span\")\n      .html(\")\")\n\n    legendDiv.exit().remove()\n\n    // returns a function to draw a line (the newLine simply has y=0 all along)\n    let interpolatedLine = d3.line().curve(d3.curveLinear).x( hy=>xScale(hy.year) ).y( hy=> yScale(hy.pop) );\n    let newLine =          d3.line().curve(d3.curveLinear).x( hy=>xScale(hy.year) ).y(yScale(0));\n\n    // LINES\n    let hyLines = this.svg.selectAll(\".line\").data(\n      self.displayedCommunes.filter((c,i)=>i<self.maxSize),\n      function(c){return c? self.lineClass(c) : this.id} // /!\\ function(){} needed here! arrow func not allowed\n    )\n    let hyLinesEnter = hyLines.enter()\n      .append(\"path\")\n      .attr(\"id\",self.lineClass)\n      .attr(\"class\",\"line\")\n      .attr(\"d\", c =>  newLine(c.hab_year))\n      .style('stroke',c => c.graphColor)\n      //.attr(\"clip-path\", \"url(#clipTemp)\")\n      .attr(\"fill\",\"none\")\n      //.attr(\"d\", c => interpolatedLine(c.hab_year))\n    \n    hyLines.exit().remove()\n\n    hyLines = hyLines.merge(hyLinesEnter)\n      .transition().duration(self.transitionsDuration)\n      .attr(\"d\", c => interpolatedLine(c.hab_year))\n\n      \n    // POINTS\n    let hyPoints = this.svg.selectAll(\".points-g\").data(\n      self.displayedCommunes.filter((c,i)=>i<self.maxSize),\n      function(c){return c? self.pointsClass(c) : this.id} // /!\\ function(){} needed here! arrow func not allowed\n    )\n      \n    let hyPointsEnter = hyPoints.enter()\n      .append('g')\n      .attr('id', self.pointsClass)\n      .attr('class', \"points-g\")\n      .each(function(commune){\n        let points = d3.select(this).selectAll(\".point\").data(commune.hab_year)\n        points.enter()\n          .append('circle')\n          .attr('class', \"point\")\n          .attr('cx', hy=>xScale(hy.year))\n          .attr('cy', yScale(0))\n          .attr('r',3)\n          .style('fill',commune.graphColor);\n      })\n\n    hyPoints.exit().remove()\n\n    hyPoints = hyPoints.merge(hyPointsEnter)\n      .each(function(commune){\n        d3.select(this).selectAll(\".point\")\n          .transition().duration(self.transitionsDuration)\n          .attr('cx', hy=>xScale(hy.year))\n          .attr('cy', hy=>yScale(hy.pop))\n      })\n\n     // Interaction events on graphic\n    this.svg.selectAll('.point')\n    // Adding information on specific point to the tooltip on mouseover\n      .on('mouseover', function(d){\n        let dot = d3.select(this)\n        let cx = dot.attr('cx') // To get appropriate coordinates for tooltip\n        let cy = dot.attr('cy') // To get appropriate coordinates for tooltip\n        self.tooltip.html(`annÃ©e: ${d.year}<br/>pop: ${d.pop}`)\n        .style('left', `${cx-10}px`)\n        .style('top', `${cy-25}px`);\n        self.tooltip.transition()\n        .duration(100)\n        .style('opacity', 0.8);\n      })\n      // Remove tooltip on mouseout\n      .on('mouseout', function(d){\n          self.tooltip.transition()\n          .duration(200)\n          .style('opacity', 0);\n      });\n\n    /*/ Replace part of the labels for french format\n    $('text').each(function(){\n        let legendText = $(this).text().replace(',',\"'\");\n        $(this).text(legendText);\n    });*/\n}\n\n  // returns a class for points, lines and legend of given commune\n  pointsClass(commune){return 'point-'+commune.name.replace(/\\W/g,\"-\")}\n  lineClass(commune){return 'line-'+commune.name.replace(/\\W/g,\"-\")}\n  legendId(commune){return 'legend-'+commune.name.replace(/\\W/g,\"-\")}\n}\n\n\n//# sourceURL=webpack:///./js/HistoricalPopulationGraph.js?");

/***/ }),

/***/ "./js/HistoricalPopulationMap.js":
/*!***************************************!*\
  !*** ./js/HistoricalPopulationMap.js ***!
  \***************************************/
/*! exports provided: HistoricalPopulationMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HistoricalPopulationMap\", function() { return HistoricalPopulationMap; });\n\n\n// SPTM - Didier Dupertuis & Nicolas Vallotton - Avril 2019\n\n\nclass HistoricalPopulationMap{\n  \n  /** HistoricalPopulationMap constructor\n   * \n   * @param {String} divId the id of the div in which the map should be put\n   * @param {Array[Commune]} communes array of Commune Objects\n   * @param {String} tilesURL a URL from which to fetch the background map data\n   * @param {number} currentYear the year at which the map should be displayed, defaults to minYear\n   * @param {number} minYear the minimum year that can be displayed\n   * @param {number} maxYear the maximum year that can be displayed\n   * @param {Object} LeafletMapArguments the arguments for the Leaflet Map object, default value given by HistoricalPopulationMap.defaultLeafletMapArguments()\n   */\n  constructor(divId, communes, tilesURL, currentYear, minYear, maxYear, LeafletMapArguments, APP){\n    this.divId = divId\n    this.communes = communes\n    this.tilesURL = tilesURL\n    this.currentYear = currentYear\n    this.minYear = minYear\n    this.maxYear = maxYear\n    this.LeafletMapArguments = LeafletMapArguments? LeafletMapArguments : HistoricalPopulationMap.defaultLeafletMapArguments();\n    this.tooltip = undefined\n    this.showCommunesWithData = true\n    this.showCommunesWithoutData = true\n    this.APP = APP\n  }\n\n  /** Initializes the map background and tooltip object */\n  init(){\n    // useful for functions not owned by this\n    let self = this\n\n    // Initialize the map - definig parameters and adding cartodb basemap\n    let map = new L.map(this.divId, this.LeafletMapArguments)\n    let cartodb = L.tileLayer(this.tilesURL, {});\n\n    // Getting tooltip ready for showing data\n    this.tooltip = d3.select('#'+this.divId)\n      .append('div')\n      .attr('class', 'tooltip');\n\n    // Add the cartodb layer to the map\n    cartodb.addTo(map);\n\n    // Creating the communes' data circles layer with\n    // leaflet d3 svg overlay according to correct projection\n    let communesOverlay = L.d3SvgOverlay(function(sel,proj){\n      // careful: here, \"this\" refers to internal L.d3SvgOverlay component, \n      // not HPM instance\n      var communesUpd = sel.selectAll('circle').data(self.communes);\n      communesUpd.enter()\n      .append(\"circle\")\n      .attr('cx', function(d){return proj.latLngToLayerPoint(d.latLng).x;}) // projecting points\n      .attr('cy', function(d){return proj.latLngToLayerPoint(d.latLng).y;}) // projecting points\n      .attr('r', 0)\n      .style('position', 'relative')\n      .attr('opacity', .6)\n      .attr('class', \"communesPop dot\");\n    });\n    // Adding layer to the map\n    communesOverlay.addTo(map);\n\n    \n    this.dataCircles()\n      // on mouseenter: slightly increase circle size + show tooltip\n      .on('mouseenter',function(d){\n        d3.select(this)\n          .transition()\n          .duration(100)\n          .attr('r', function(d){\n              return 1.3*d.circleSize\n          });\n        self.tooltip.html(function(){\n            return `${d.name}, pop: ${Math.round(d.calculatePopulation(self.currentYear))}`\n        })\n        .transition()\n        .duration(50)\n        .style('opacity', 0.8)\n        .style('left', `${d3.event.pageX}px`)\n        .style('top', `${d3.event.pageY}px`);\n      })\n      // on mouseout: reset normal circle size + hide tooltip\n      .on('mouseout', function(){\n          d3.select(this)\n          .transition()\n          .duration(200)\n          .attr('r', d=> d.circleSize);\n          self.tooltip.transition()\n          .duration(200)\n          .style('opacity', 0);\n      });\n  }\n\n  /** Updates visible states of all the dots: size, color (interpolated/real data) and display status */\n  update(transitionMsec){\n    // display pop as it is at this.APP.currentYear\n    this.dataCircles()\n        .classed('extrapolated', d=> !d.hasPopulationData(this.currentYear))\n        .classed('intrapolated', d=> d.hasPopulationData(this.currentYear))\n        .transition().duration(transitionMsec)\n        .attr(\"r\",d=>{\n          d.circleSize = Math.sqrt(+d.calculatePopulation(this.currentYear))/14\n          return d.circleSize\n        })\n    \n    d3.selectAll('.dot.intrapolated').classed(\"hidden\", !this.showCommunesWithData)\n    d3.selectAll('.dot.extrapolated').classed(\"hidden\", !this.showCommunesWithoutData)\n  };\n\n  /** Update the year of data shown */\n  updateYear(year, transitionMsec){\n    this.currentYear = year\n    this.update(transitionMsec)\n  }\n\n  /** Returns a d3 selection of all the commuens' data circles */\n  dataCircles(){return d3.selectAll(\"#\" + this.divId + ' .dot')}\n\n  /** Toggles whether do show or hide communes with data at given year */\n  toggleShowCommunesWithData(){\n    this.showCommunesWithData = !this.showCommunesWithData\n    this.update()\n  }\n\n  /** Toggles whether do show or hide communes without data at given year */\n  toggleShowCommunesWithoutData(){\n    this.showCommunesWithoutData = !this.showCommunesWithoutData\n    this.update()\n  }\n\n  /** Default arguments for Leaflet Map background */\n  static defaultLeafletMapArguments(){\n    return {\n      center: [\t46.8,8.2],\n      zoom: 8,\n      minZoom: 8,\n      maxZoom: 20,\n      maxBounds: ([[44.5, 4.5],[49, 12]])\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./js/HistoricalPopulationMap.js?");

/***/ }),

/***/ "./js/index.js":
/*!*********************!*\
  !*** ./js/index.js ***!
  \*********************/
/*! exports provided: APP */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"APP\", function() { return APP; });\n/* harmony import */ var _HistoricalPopulationGraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HistoricalPopulationGraph.js */ \"./js/HistoricalPopulationGraph.js\");\n/* harmony import */ var _HistoricalPopulationMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HistoricalPopulationMap.js */ \"./js/HistoricalPopulationMap.js\");\n/* harmony import */ var _Commune_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Commune.js */ \"./js/Commune.js\");\n\n\n\n\n// SPTM - Didier Dupertuis & Nicolas Vallotton - Avril 2019\n\n// Creating APP object for storing all Methods\nlet APP = {\n  minYear: 1200,\n  currentYear: 1536,\n  maxYear: 1990,\n  // list of communes\n  communes:[],\n  communesFile: \"3_maps/communes_geo.csv\",\n  ygrs:[],\n  ygrFile: \"3_maps/avg_yearly_growth_rates.csv\",\n  showCommunesWithData: true,\n  showCommunesWithoutData: true,\n  mapTransitionDuration: 1000,\n  mapTransitionDurationDefault: 1000,\n  i18nDir: \"3_maps/assets/translations/\",\n  animationTotalTime: 7900,\n  animationIntervalTime: 100,\n  animationTimeoutId: undefined,\n  animationIntervalId: undefined,\n  animationStartTime: +new Date(),\n  animationShowPlayButton: true\n};\n\n\n\n\n/*****\nDeclaring global variables\n*****/\n\nlet cl = console.log\nlet ct = console.table\n\n// Storing size of the browser viewport\nlet windowHeight = $(window).height();  // returns height of browser viewport\nlet windowWidth = $(window).width();  // returns width of browser viewport\n\n\n// Correspondance table for slider values, buffer label in meters, buffer sizes in pixel and pop values for each\n// let bufferVal = []; // initialized empty\n// for(i = 1; i <= 10; i++){\n    // bufferVal.push({\"sliderVal\": i, \"buffer\": `${i*100}m`, \"bufferPx\": i*15, \"pop\":`pop${i*100}m`});\n// }\n\n/*****\nInitializing the whole script of the page\n*****/\nAPP.main = async function(){\n    APP.togglePlayPauseButtons(true)\n\n    // load communes data\n    APP.communes = await d3.dsv(\";\",APP.communesFile, function(d){\n      return new _Commune_js__WEBPACK_IMPORTED_MODULE_2__[\"Commune\"](\n        d.bfsnr, d.name, d.canton_x, d.firstmention, JSON.parse(d.hab_year.replace(/'/g,'\"') ),\n        d.Y, d.X, d.url, d.zipcodes, d.language, d.notes, APP.extrapolatePop\n      )\n    })\n\n    console.log(\"APP.communes 0:\", APP.communes)\n\n    APP.hpm = new _HistoricalPopulationMap_js__WEBPACK_IMPORTED_MODULE_1__[\"HistoricalPopulationMap\"](\n      \"map\", APP.communes,\n      'https://api.mapbox.com/styles/v1/nvallott/cjcw1ex6i0zs92smn584yavkn/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoibnZhbGxvdHQiLCJhIjoiY2pjdzFkM2diMWFrMzJxcW80eTdnNDhnNCJ9.O853joFyvgOZv7y9IJAnlA',\n      1536, 1200, 1990, false, APP\n    )\n    APP.hpm.init();\n    APP.graph = new _HistoricalPopulationGraph_js__WEBPACK_IMPORTED_MODULE_0__[\"HistoricalPopulationGraph\"](\n      \"graph\",\n      \"graphLegend2\",\n      1200, 1990\n    )\n\n    // communes circle onclick: display on graph\n    APP.hpm.dataCircles().on('click', c => APP.graph.addCommune(c))\n\n    APP.sliderevent();\n    await APP.loadYearlyGrowthRates()\n\n    document.getElementById(\"slider1\").value = APP.currentYear; \n\n    APP.updateYear()\n\n    // add buttons event listeners\n    document.getElementById(\"map-animation-minus-50y\").addEventListener(\"click\", ()=> APP.animationStart(Math.max(APP.minYear,APP.currentYear-50)))\n    document.getElementById(\"map-animation-play\").addEventListener(\"click\", ()=> APP.animationStart())\n    document.getElementById(\"map-animation-pause\").addEventListener(\"click\", ()=> APP.animationStop())\n    document.getElementById(\"map-animation-plus-50y\").addEventListener(\"click\", ()=> APP.animationStart(Math.min(APP.maxYear,APP.currentYear+50)))\n    document.getElementById(\"map-toggle-with-data\").addEventListener(\"click\", ()=> {\n      APP.hpm.toggleShowCommunesWithData()\n      d3.select(\"#legend-original-pop-data button\")\n          .attr(\"data-i18n\",()=> (APP.hpm.showCommunesWithData? \"hide\":\"show\")+\"-communes-button\")\n    })\n    document.getElementById(\"map-toggle-without-data\").addEventListener(\"click\", ()=> {\n      APP.hpm.toggleShowCommunesWithoutData()\n      d3.select(\"#legend-extrapolated-pop-data button\")\n          .attr(\"data-i18n\",()=> (APP.hpm.showCommunesWithoutData? \"hide\":\"show\")+\"-communes-button\")\n    })\n};\n\n/*****\nLoading yearly growth rates data\n*****/\nAPP.loadYearlyGrowthRates = async function(){\n  APP.ygrs = await d3.dsv(\";\",APP.ygrFile, function(ygr){\n    ygr.year=parseInt(ygr.year)\n    ygr.data_pop=parseInt(ygr.data_pop)\n    ygr.duration=parseInt(ygr.duration)\n    ygr.ygr=parseFloat(ygr.ygr)\n    ygr.gr=parseFloat(ygr.gr)\n    return ygr\n  })\n}\n\n// calculates total growth rate between two given year, assumes y1<y2\nAPP.calculateGrowthRate = function (y1,y2){\n  let ygrs12 = APP.ygrs.filter((ygr,i) => \n    (ygr.year>=y1 || (APP.ygrs[i+1] && APP.ygrs[i+1].year>y1)) &&\n     ygr.year<y2 )\n  if(ygrs12.length>0){\n    let ygrLast = ygrs12[ygrs12.length-1]\n    let y2Duration = y2 - ygrLast.year\n    ygrs12[ygrs12.length-1] = {\n      year: ygrLast.year,\n      ygr: ygrLast.ygr,\n      gr: ygrLast.ygr ** y2Duration,\n      duration: y2Duration,\n    }\n\n    let ygrFirst = ygrs12[0]\n    let y1Duration = ygrFirst.duration - (y1-ygrFirst.year)\n    ygrs12[0] = {\n      year: y1,\n      ygr: ygrFirst.ygr,\n      gr: ygrFirst.ygr ** y1Duration,\n      duration: y1Duration,\n    }\n\n    return ygrs12.reduce((tot,ygr) => tot*ygr.gr, 1)\n  }\n  return null\n}\n\n// extrapolate pop of a commune in the past\nAPP.extrapolatePop = function(commune, year){\n  let hy1 = commune.hab_year[0]\n  //cl(\"year: \",year)\n  //cl(\"hy1: \", hy1, \", bool(hy1): \", Boolean(hy1), \", hy1.year: \", hy1.year, \", hy1.year>year: \", hy1.year>year, \", hy1 && hy1.year>year: \", hy1 && hy1.year>year)\n  if(hy1 && hy1.year>year){\n    return hy1.pop / APP.calculateGrowthRate(year,hy1.year)\n  }\n  return null\n}\n\n\n\n\nAPP.animate = function(startYear=APP.minYear, endYear=APP.maxYear, timeout=APP.animationTotalTime, interval=APP.animationIntervalTime){\n  APP.animationStop()\n  let diffYear = endYear-startYear\n  let slider = document.getElementById(\"slider1\")\n  slider.value = startYear\n  APP.updateYear(0)\n  APP.togglePlayPauseButtons(false)\n  APP.animationStartTime = +new Date()\n  let intervalId = setInterval(function(){\n    let newTime = +new Date()\n    APP.currentYear = Math.round(startYear + diffYear * (newTime-APP.animationStartTime) / timeout)\n    slider.value = APP.currentYear\n    APP.updateYear(0)\n  }, interval)\n  APP.animationIntervalId = intervalId\n  let timeoutId = setTimeout(()=>APP.animationStop(endYear, intervalId, timeoutId),timeout+1)\n  APP.animationTimeoutId = timeoutId\n  return func => setTimeout(func, timeout+1);\n}\nAPP.animationStop = function(endYear=APP.currentYear, intervalId=APP.animationIntervalId, timeoutId=APP.animationTimeoutId){\n  APP.currentYear = endYear\n  document.getElementById(\"slider1\").value = APP.currentYear\n  APP.updateYear(0)\n  APP.togglePlayPauseButtons(true)\n  clearInterval(intervalId)\n  clearTimeout(timeoutId)\n}\nAPP.animationStart = function(endYear = APP.maxYear){\n  let factor = Math.abs(endYear-APP.currentYear) / (APP.maxYear-APP.minYear)\n  let timeout = APP.animationTotalTime * factor \n  cl(\"APP.animationStart timeout\",timeout,\", endYear\",endYear,\"  Math.abs(endYear-APP.currentYear) \",Math.abs(endYear-APP.currentYear), \", factor\",factor)\n  return APP.animate(APP.currentYear, endYear, timeout, APP.animationIntervalTime)\n}\n\nAPP.togglePlayPauseButtons = function(showPlay = !APP.animationShowPlayButton){\n  if(showPlay){  \n    $(\"#map-animation-pause\").hide()\n    $(\"#map-animation-play\").show()\n  } else{\n    $(\"#map-animation-pause\").show()\n    $(\"#map-animation-play\").hide()\n  }\n  APP.animationShowPlayButton = showPlay\n}\n\n/*****\nUpdating innerHTML of buffer size values according to slider value using conversion table\n*****/\nAPP.sliderevent = function(){\n    $('.slidBuffer')\n    .on(\"input\",function(){\n      APP.currentYear = parseInt($('#slider1').val())\n      APP.updateYear()\n    })\n    // allow smooth 1sec transition for clicks and immediate changes when dragging\n    .on(\"mousedown\",function(){\n      setTimeout(()=>{APP.mapTransitionDuration=0},10)\n    })\n    .on(\"mouseup\",function(){\n      setTimeout(()=>{APP.mapTransitionDuration=APP.mapTransitionDurationDefault},11)\n    })\n}\n\nAPP.updateYear = function(transitionMsec=APP.mapTransitionDuration){\n  $(\"#slider1_val\").html(APP.currentYear)\n  APP.i18n.data(\"label-original-pop-data\",APP.communes.filter(c => c.hab_year[0]? c.hab_year[0].year<=APP.currentYear:false).length)\n  //$(\"#nb-communes-data\").html(APP.communes.filter(c => c.hab_year[0]? c.hab_year[0].year<=APP.currentYear:false).length)\n  APP.hpm.updateYear(APP.currentYear, transitionMsec)\n}\n\n\n\n\n\n\nasync function languageLoader(lng){\n  let translation = await fetch(APP.i18nDir+lng+\".json\")\n  //console.log( \"translation.status: \", translation.status, \", translation: \", translation)\n  if(translation.status==200){\n    translation = await translation.json()\n    return translation\n  }else{\n    throw {\n      message: 'loading of translation \"'+lng+'\" failed',\n      lng: lng,\n      response: translation\n    }\n  }\n}\n\nAPP.i18n = new Internationalisation([\"fr\",\"de\",\"it\",\"en\"],languageLoader)\n//APP.i18n.useLocalStorage = false\nAPP.i18n.dynamic[\"label-original-pop-data\"] = (t,d) => t.replace(\"{#nbcommunes}\",d)\nfunction onChangeLanguage(oldLng, newLng){\n  $(\"#lang-dropdown .lang-current\").text(\" \"+newLng.toUpperCase()+\" \")\n}\nAPP.i18n.languageChangeCallbacks.push(onChangeLanguage)\nAPP.i18n.observe(document)\n\n// add language choice buttons:\nfor(let lng of APP.i18n.supportedLanguages){\n  let langMenu = d3.select(\"#lang-menu\")\n  langMenu.append(\"a\")\n      .attr(\"class\",\"dropdown-item\")\n      .attr(\"href\",'javascript:void(0);')\n      .html(lng.toUpperCase())\n      .on(\"click.change-language\", ()=> APP.i18n.changeLanguage(lng))\n  langMenu.append(\"br\")\n}\n\nAPP.main();\n\n\n//# sourceURL=webpack:///./js/index.js?");

/***/ }),

/***/ "./js/util.js":
/*!********************!*\
  !*** ./js/util.js ***!
  \********************/
/*! exports provided: interpolator, exponentialInterpolator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"interpolator\", function() { return interpolator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exponentialInterpolator\", function() { return exponentialInterpolator; });\n\n\n/** Returns a linear interpolator from the given dataPoints\n * @param {*} dataPoints an array of length 2 arrays, each sub-array is a coordinate with sub-array[0]=x, sub-array[1]=y\n * @returns interpolate(x) a function taking a value x and returning the linear interpolation of y at x, or null if x is outside the x range of dataPoints\n */\nfunction interpolator(dataPoints){\n  dataPoints.sort((a,b)=>a[0]-b[0])\n  //cl(\"dataPoints\",dataPoints)\n  return function interpolate(x){\n    if(dataPoints[0] && x==dataPoints[0][0]){\n      return dataPoints[0][1]\n    }\n    let bi = dataPoints.findIndex(b=>b[0]>=x)\n    if(bi>0 && bi<=dataPoints.length){\n      let a = dataPoints[bi-1]\n      let b = dataPoints[bi]\n      //cl(\"a=\",a,\", b=\",b, \", b[1]-a[1]=\", b[1]-a[1], \", b[0]-a[0]=\", b[0]-a[0], \", x-a[0]=\", x-a[0])\n      return a[1]+ (b[1]-a[1])/(b[0]-a[0]) * (x-a[0])\n    }\n    return null\n  }\n}\n/** Returns an exponential interpolator from the given dataPoints\n * Useful to interpolate with growth rates\n * @param {*} dataPoints an array of length 2 arrays, each sub-array is a coordinate with sub-array[0]=x, sub-array[1]=y\n * @returns interpolate(x) a function taking a value x and returning the exponential interpolation of y at x, or null if x is outside the x range of dataPoints\n */\nfunction exponentialInterpolator(dataPoints){\n  let linearInterpolator = interpolator(dataPoints.map(dp=>[dp[0],Math.log(dp[1])]))\n  return function(year){\n    let logResult = linearInterpolator(year)\n    if(logResult===null){\n      return null\n    }\n    return Math.exp(logResult)\n  }\n}\n\n//# sourceURL=webpack:///./js/util.js?");

/***/ })

/******/ });